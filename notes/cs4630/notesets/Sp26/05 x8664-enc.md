* x86 assembly is just the human-readable version of machine code. Machines don't actually read x86 assembly, e.g. `add %bl, %cl`; they read binary/hex, e.g. `02 CB`. The process of mapping the human-readable assembly to binary/hex is called **encoding**. 
* Steps to encode an x86 instruction, for an **16-bit 8086 processor**
    * Determine the opcode using the {{Intel manual}}. If an `/r` comes at the end of the opcode, that means {{the encoding requires one additional byte of info, called the `ModRM` byte}}.
    * If necessary, build the `ModRM` byte: the first two bits are {{`mod` (the addressing "mod"e)}}, the next three bits are {{the first register, also called `reg`}}, and the last three are {{the second register, also called `r/m`}}. We do this using the `ModRM` table.
![16-bit ModRM table](./assets/images/image-1.png)
* 
    * Note that the register portion (`eax/ax/al`) is determined by tge opcode. So for example, if we wanted to encode `add CL, BL`, and we knew the Intel manual said the opcode was `0x02 /r`, then we can use this table to find the final encoding (in binary/hex) is {{`00000010 11 001 011` or `02 cb`}}.
* In 32-bit mode, instructions sometimes need an extra byte of info (in additional to the `ModRM` byte) called the {{SIB byte}}. For example, this occurs when (?). With that said, these are the steps to encode an x86 instruction in 32 bits:
    * Determine the {{opcode}} (see 16-bit) using the {{Intel manual}}
    * Determine {{`reg`}} and {{`r/m`}} using the {{`ModRM` table}}
![alt text](./assets/images/image.png)
* 
    * Determine whether or not you need the SIB byte. If {{`r/m` == `0b100` and `mod` != `0b11`}}, then you do.
    * If you have an SIB byte, determine it. 
        * The first two bits are the {{scale}}. `00` = {{1}}, `01` = {{2}}, `10` = {{4}}, `11` = {{8}}.
        * The next three bits are the {{index}}, and the last three are the {{base}}.
# left off on 20