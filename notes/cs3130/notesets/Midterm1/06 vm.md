* A process’s memory is divided into conceptual regions such as {{code, writable data, heap, and stack}}. The operating system reserves part of the address space for {{itself}}, typically at high addresses.
    * The stack grows in what direction? {{Downward from high virtual addresses}}. 
    * The heap grows in what direction? {{Upward from lower addresses}}.
    * The code and constant data live at the {{lowest}} virtual addresses.
* Each process believes that it owns {{a full, private address space}} starting at address {{0}}.
    * In reality, {{multiple processes share the same physical memory}}. The OS creates a mapping from each process’s virtual addresses to physical memory locations.
    * During a context switch, the OS swaps {{which mapping is active}}, giving each process its own “view” of memory.
    * Some regions (kernel memory) are marked as accessible only in kernel mode.
![image 1](image.png)
* Every time the program accesses memory, it uses a {{virtual address}} generated by the CPU. The OS and hardware translate this into a {{physical address}} before accessing RAM.
    * Virtual and physical address spaces can have different sizes. The virtual address space is divided into fixed-size blocks called {{pages}}.
    * Because page sizes are always {{powers of two}}, the upper bits of an address form the {{"virtual page number" (VPN)}}, and the lower bits form {{the page offset}}. 
![alt text](image1.png)
*   
    * Each virtual page is conceptually assigned to {{a region}} (ex. {{code, data/heap, stack, or unused}}).
* Physical memory is also divided into fixed-size physical pages. Virtual pages do not need to {{appear in order in physical memory}}. Some virtual pages may not be {{mapped at all}}.
* A page table stores {{the mapping from virtual page numbers to physical page numbers}}. 
    * Each entry contains:
        * The "valid" bit: indicates whether {{the virtual page is currently mapped}}.
        * PPN: {{the physical page number}} if valid.
    * Page table usage: The {{CPU}} uses the {{VPN}} to index into the page table and retrieve the {{PPN}}. If {{the valid bit is 0}}, the CPU raises a page fault.
* When comparing the size of a pointer and the size of a virtual address, a pointer can be larger than a virtual address, but not the other way around. If the pointer size is larger than the virtual address's size, then the rest of the bits just have a fixed value.
    * The more unique addresses you have, the more a address space you have. Meaning, the more bits used to express a virtual address, the larger the virtual address size. For example, a 32-bit address has a {{2^32}}-byte address space.
    * If for some reason, the hardware has a memory size that isn't a power of 2, then e{{xtra memory past the nearest power of 2 is simply unused}}.
    * Example: if you had a 32-bit virtual address size, and 4096-byte pages (2^12), then there would be {{2^32 / 2^12 = 2^20}} pages.
* If the physical addresses use less bits than the virtual addresses do, some virtual addresses simply remain unmapped, i.e. certain virtual pages are not valid.
    * Example: If you have 32-bit virtual addresses and 30-bit physical addresses, with 4096-byte (2^12) pages, the page table will have {{2^20}} entries. The entries for unmapped virtual addresses will {{be included, but with the valid bit set to 0}}.
    * Example: If you had a page table with 2^20 entries, the address  `0x12345678` would have a page number of {{`0x12345`}} and a offset of {{`0x678`}}. This is because {{we know 20 bits are used to store the page number, which corresponds to five hex digits}}. 

Simplified page table example:
| VPN | valid | PPN |
|----------|----------|----------|
| 000    | 1   | 0010   |
| 001    | 1   | 1010   |
* Example: if you had 64-byte pages and the page table above, what physical address would the virtual address `0 0010 0100` translate to (in hex)?: {{`0x0A4`}}. This is because {{64 = 2^6, meaning page sizes are 6 bits, meaning page offsets are 6 bits. So the three most significant bits, `000`, are the VPN}}.

* In addition to the valid bit, the VPN and the PPN, a page table entry also usually includes {{permissions bits}} in order to {{enforce permissions on the OS level...duh}}.
* In practice, the OS only allocates as much stack space as is being used. This means many {{stack pages}} remain unmapped to physical pages, i.e. their {{valid bit}} is set to `0`.
    * If it runs into an instruction that requests stack space that is currently unmapped (valid bit equals {{`0`}}), then {{exception is triggered}}.
    * In the exception handler, the OS {{allocates more stack space and updates the page table}}. Then the instruction is retried. 
    * Sometimes, zero stack pages are loaded when the program starts up. And all stack space is allocated via {{exceptions}}.
* Similarly, when duplicate processes run, the OS shares as mch info between them as possible. For example, {{read-only}} pages are always shared between duplicate processes .
    * Writable pages will be shared between duplicate pages, too, as long as {{neither process has modified the data (yet)}}. At this stage (before any modifications), these pages are marked {{read-only}} in the page table so that {{writing to them will trigger an exception}}. Importantly, the process that didn't write to the data stays associated with the read-only page.
    * In the handler for such an exception, the OS then {{makes a copy of the page, updates its permission to writable}}, then returns to re-try the instruction. This has the end result of copying over data only when it's absolutely needed. We call this technique {{copy-on-write}}. 
* `mmap` creates a virtual memory region whose contents come from {{a file}}. The return value, `data`, is a pointer into your virtual address space.
    * Reading from `data[i]` causes the OS to {{load the corresponding page of the file into memory on demand}}. Writing to `data[i]` modifies the in‑memory page.
    * You can treat the mapped region exactly like an array, but the OS is secretly doing {{page‑fault}}‑driven I/O behind the scenes.
    * Linux models every region of a process’s memory as if {{it were created by `mmap`}}. 
        * When a program is loaded, its code and data come from the {{executable file}}. These pages are initially {{shared and read‑only}}. If the program writes to one of these pages, the OS: {{allocates a new physical page, copies the original contents, and updates the page table entry}}.
        * Other stuff that requires memory but isn't loaded from disk, like the {{stack and heap}}, are allocated a "backing file" that is full of {{zeroes}} on demand. This is called {{anonymous mapping}}.
* `/proc/self/maps` is how Linux tracks {{memory regions}}. Each virtual memory address is represented by an entry in the table, which can be though of as a C {{`struct vm_area_struct`}}. This entry includes stuff like {{start and end VMAs, perms, the offset into the backing file, etc.}}
    * The difference between `/proc/self/maps` and page tables is that {{`/proc/self/maps` describes logial regions of memory, so it's for the OS. On the other hand, page tables describe page-by-page mappings, so it's for the hardware}}.
* In general, page tricks work as the following: we deliberately {{make program trigger page/protection fault}}, but don’t assume {{page/protection fault is an error}}, and have have seperate data structures represent {{logically allocated memory}}. 
    * Example page table tricks include: {{allocating space on demand, loading code/data from files on disk on demand, copy-on-write, saving data temporarily to disk, reloading to memory on demand, “swapping”, detecting whether memory was read/written recently, stopping in a debugger when a variable is modified, sharing memory between programs on two different machines}}.
    * Some ways that the hardware assists page table tricks: {{stores the address causing the fault in a special register, automatically rerun faulting instruction when returning exception, not allowing any side effects from the faulting instruction such as incrementing `%rsp`}}
# left off on 81